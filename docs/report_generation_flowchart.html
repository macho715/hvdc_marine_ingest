<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>보고서 생성 로직 플로우차트 - v2.7 (GIS + ML 통합)</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 40px;
            font-size: 2.5em;
        }
        .diagram-container {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid #e9ecef;
        }
        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .code-block {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>📝 보고서 생성 로직 플로우차트</h1>
        
        <div class="info-box">
            <h3>시스템 정보</h3>
            <p><strong>버전:</strong> v2.7 Production Ready</p>
            <p><strong>파일:</strong> scripts/weather_job.py, weather_job_3d.py</p>
            <p><strong>함수:</strong> generate_summary_report(), render_html_3d(), write_side_outputs()</p>
            <p><strong>출력:</strong> 4가지 형식 (JSON, CSV, TXT, HTML) + GIS Maps + ML Forecasts</p>
        </div>
        
        <div class="info-box" style="background: #e1f5fe; border-left-color: #2196f3;">
            <h3>⭐ v2.7 신규 출력</h3>
            <p><strong>GIS:</strong> map_leaflet.html (Leaflet 지도), wind_uv.geojson (108 vectors), screenshots</p>
            <p><strong>ML:</strong> summary_3d_*_ml.csv (7-day predictions), anomaly alerts (z-score)</p>
            <p><strong>통합:</strong> run_integrated_viz.py (데이터 수집 + GIS + ML 한 번에)</p>
        </div>

        <!-- 전체 파이프라인 -->
        <h2>🔄 전체 보고서 생성 파이프라인</h2>
        <div class="diagram-container">
            <div class="mermaid">
graph TD
    A[시작: weather_job.py] --> B[1. 데이터 수집<br/>collect_weather_data]
    
    B --> C{실행 모드<br/>결정}
    C -->|오프라인| D[합성 데이터 생성<br/>24 points]
    C -->|온라인| E[실제 API 호출<br/>121 points]
    
    D --> F[2. 데이터 분석<br/>analyze_weather_data]
    E --> F
    
    F --> G[ERI 계산<br/>ERICalculator]
    G --> H[예보 융합<br/>ForecastFusion]
    H --> I[운항 판정<br/>OperationalDecisionMaker]
    
    I --> J[3. 보고서 생성<br/>generate_summary_report]
    
    J --> K1[JSON 보고서<br/>summary_YYYYMMDD_HHMM.json]
    J --> K2[CSV 보고서<br/>api_status_YYYYMMDD_HHMM.csv]
    J --> K3[TXT 보고서<br/>summary.txt]
    J --> K4[HTML 보고서<br/>summary.html]
    
    I --> L[4. 운항 가능성 예측<br/>create_operability_report]
    L --> M1[operability_forecasts.csv]
    L --> M2[eta_predictions.csv]
    
    K3 --> N[Telegram 알림]
    K4 --> O[Email 알림]
    
    style K1 fill:#e3f2fd
    style K2 fill:#e8f5e9
    style K3 fill:#fff3e0
    style K4 fill:#fce4ec
    style N fill:#e1bee7
    style O fill:#f3e5f5
            </div>
        </div>

        <!-- generate_summary_report 상세 플로우 -->
        <h2>📝 generate_summary_report 함수 상세</h2>
        <div class="diagram-container">
            <div class="mermaid">
graph TD
    A[입력: data, analysis, output_dir] --> B[디렉토리 생성<br/>output_path.mkdir]
    B --> C[타임스탬프 생성<br/>YYYYMMDD_HHMM]
    
    C --> D[메타데이터 구성]
    D --> D1[execution_mode]
    D --> D2[collection_rate]
    D --> D3[resilience_notes]
    
    D3 --> E[JSON 보고서 생성]
    E --> E1[metadata 섹션]
    E --> E2[api_status 섹션]
    E --> E3[analysis 섹션]
    E --> E4[collection_stats 섹션]
    E --> E5[파일 저장<br/>json.dump]
    
    E5 --> F[CSV 보고서 생성]
    F --> F1[csv_data 리스트 구성]
    F --> F2[DataFrame 변환]
    F --> F3[파일 저장<br/>df.to_csv]
    
    F3 --> G[TXT 보고서 생성]
    G --> G1[헤더 섹션]
    G --> G2[데이터 수집 현황]
    G --> G3[분석 결과]
    G --> G4[운항 판정]
    G --> G5[Resilience 메모]
    G --> G6[파일 저장<br/>summary.txt]
    
    G6 --> H[HTML 보고서 생성]
    H --> H1[DOCTYPE + 스타일]
    H --> H2[헤더 섹션<br/>메타데이터]
    H --> H3[테이블 섹션<br/>데이터 수집 현황]
    H --> H4[리스트 섹션<br/>분석 결과]
    H --> H5[판정 섹션<br/>GO/COND/NO-GO]
    H --> H6[Resilience 메모]
    H --> H7[파일 저장<br/>summary.html]
    
    H7 --> I[반환: 파일 경로 딕셔너리]
    
    style E5 fill:#e3f2fd
    style F3 fill:#e8f5e9
    style G6 fill:#fff3e0
    style H7 fill:#fce4ec
    style I fill:#c5cae9
            </div>
        </div>

        <!-- 데이터 처리 상세 -->
        <h2>⚙️ 데이터 처리 로직 상세</h2>
        
        <table>
            <thead>
                <tr>
                    <th>단계</th>
                    <th>함수/모듈</th>
                    <th>입력</th>
                    <th>출력</th>
                    <th>처리 시간</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>1. 모드 결정</strong></td>
                    <td>decide_execution_mode()</td>
                    <td>mode, missing_secrets, ncm_available</td>
                    <td>resolved_mode, offline_reasons</td>
                    <td>&lt;0.01초</td>
                </tr>
                <tr>
                    <td><strong>2. 데이터 수집</strong></td>
                    <td>API Connectors</td>
                    <td>location, forecast_hours</td>
                    <td>121 data points (온라인)</td>
                    <td>&lt;30초</td>
                </tr>
                <tr>
                    <td><strong>3. ERI 계산</strong></td>
                    <td>ERICalculator.compute_eri_timeseries()</td>
                    <td>MarineTimeseries</td>
                    <td>121 ERIPoints</td>
                    <td>&lt;0.05초</td>
                </tr>
                <tr>
                    <td><strong>4. 예보 융합</strong></td>
                    <td>ForecastFusion.fuse_forecast_sources()</td>
                    <td>all_timeseries, location</td>
                    <td>121 fused forecasts</td>
                    <td>&lt;0.1초</td>
                </tr>
                <tr>
                    <td><strong>5. 운항 판정</strong></td>
                    <td>OperationalDecisionMaker.decide_and_eta()</td>
                    <td>forecasts, eri_points</td>
                    <td>121 decisions</td>
                    <td>&lt;0.02초</td>
                </tr>
                <tr>
                    <td><strong>6. 통계 계산</strong></td>
                    <td>Python sum(), avg()</td>
                    <td>eri_points, decisions</td>
                    <td>averages, counts</td>
                    <td>&lt;0.01초</td>
                </tr>
                <tr style="background: #fff3e0;">
                    <td><strong>7. 보고서 생성</strong></td>
                    <td>generate_summary_report()</td>
                    <td>data, analysis</td>
                    <td>JSON/CSV/TXT/HTML</td>
                    <td><span class="highlight">&lt;0.5초</span></td>
                </tr>
                <tr>
                    <td><strong>8. 운항 예측</strong></td>
                    <td>create_operability_report()</td>
                    <td>weather_timeseries, routes</td>
                    <td>operability CSV files</td>
                    <td>&lt;0.2초</td>
                </tr>
            </tbody>
        </table>

        <!-- 보고서 형식별 특징 -->
        <h2>📄 보고서 형식별 특징</h2>
        
        <div class="info-box" style="background: #e3f2fd; border-left-color: #2196f3;">
            <h3>📊 JSON 보고서 (summary_YYYYMMDD_HHMM.json)</h3>
            <p><strong>용도:</strong> API 통합, 데이터 분석, 자동화 처리</p>
            <p><strong>구조:</strong> 계층적 JSON (metadata, api_status, analysis, collection_stats)</p>
            <p><strong>크기:</strong> 2-3 KB</p>
            <p><strong>인코딩:</strong> UTF-8, ensure_ascii=False</p>
            <p><strong>특징:</strong> 전체 데이터 + 메타데이터 포함, Python dict와 1:1 매핑</p>
        </div>

        <div class="info-box" style="background: #e8f5e9; border-left-color: #4caf50;">
            <h3>📊 CSV 보고서 (api_status_YYYYMMDD_HHMM.csv)</h3>
            <p><strong>용도:</strong> Excel 분석, 데이터 과학, 시계열 추적</p>
            <p><strong>구조:</strong> 테이블 (API, Status, Confidence, Timestamp)</p>
            <p><strong>크기:</strong> &lt;1 KB</p>
            <p><strong>특징:</strong> pandas DataFrame 기반, API 상태 추적에 최적화</p>
        </div>

        <div class="info-box" style="background: #fff3e0; border-left-color: #ff9800;">
            <h3>📱 TXT 보고서 (summary.txt)</h3>
            <p><strong>용도:</strong> Telegram 메시지, 텍스트 기반 알림</p>
            <p><strong>구조:</strong> 플레인 텍스트, 이모지 포함</p>
            <p><strong>크기:</strong> ~1 KB</p>
            <p><strong>제한:</strong> Telegram 4096자 제한 (초과 시 Document 전송)</p>
            <p><strong>특징:</strong> 간결한 요약, 모바일 친화적</p>
        </div>

        <div class="info-box" style="background: #fce4ec; border-left-color: #e91e63;">
            <h3>📧 HTML 보고서 (summary.html) ⭐ v2.3 신규</h3>
            <p><strong>용도:</strong> Email 알림, 웹 브라우저 뷰</p>
            <p><strong>구조:</strong> Styled HTML (CSS 내장)</p>
            <p><strong>크기:</strong> 2-3 KB</p>
            <p><strong>특징:</strong> 색상 코딩, 테이블 포맷, Gmail 최적화, 시각적 보고서</p>
        </div>

        <!-- 파이프라인 플로우 -->
        <h2>🔄 데이터 처리 파이프라인</h2>
        <div class="diagram-container">
            <div class="mermaid">
sequenceDiagram
    participant Main as weather_job.py
    participant Collect as collect_weather_data()
    participant APIs as API Connectors
    participant Analyze as analyze_weather_data()
    participant ERI as ERICalculator
    participant Fusion as ForecastFusion
    participant Decision as OperationalDecisionMaker
    participant Report as generate_summary_report()
    participant Files as 출력 파일

    Main->>Collect: --location AGI --hours 24 --mode auto
    Collect->>APIs: Stormglass API 호출
    APIs-->>Collect: 48 data points (85% 신뢰도)
    Collect->>APIs: Open-Meteo API 호출
    APIs-->>Collect: 25 data points (75% 신뢰도)
    Collect->>APIs: NCM Selenium 스크래핑
    APIs-->>Collect: 24 data points (70% 신뢰도)
    Collect->>APIs: WorldTides API 호출
    APIs-->>Collect: 24 data points (30% 폴백)
    
    Collect-->>Main: 121 total points, api_status
    
    Main->>Analyze: data (121 points)
    Analyze->>ERI: compute_eri_timeseries()
    ERI-->>Analyze: 121 ERI points
    Analyze->>Fusion: fuse_forecast_sources()
    Fusion-->>Analyze: 121 fused forecasts
    Analyze->>Decision: decide_and_eta()
    Decision-->>Analyze: 121 decisions (GO/COND/NO-GO)
    
    Analyze-->>Main: analysis (통계, 평균, 판정)
    
    Main->>Report: data, analysis, "out"
    Report->>Files: summary_YYYYMMDD_HHMM.json
    Report->>Files: api_status_YYYYMMDD_HHMM.csv
    Report->>Files: summary.txt
    Report->>Files: summary.html
    
    Report-->>Main: 파일 경로 반환
    
    Main->>Main: 운항 가능성 예측
    Main->>Files: operability_forecasts.csv
    Main->>Files: eta_predictions.csv
            </div>
        </div>

        <!-- 보고서 생성 상세 플로우 -->
        <h2>📝 generate_summary_report() 상세 플로우</h2>
        <div class="diagram-container">
            <div class="mermaid">
flowchart TD
    START([시작: generate_summary_report]) --> PREP[디렉토리 생성 & 타임스탬프]
    
    PREP --> META[메타데이터 계산]
    META --> META1[execution_mode 추출]
    META --> META2[success_sources 계산]
    META --> META3[collection_rate 계산]
    META --> META4[resilience_notes 추출]
    
    META4 --> JSON[JSON 보고서 생성]
    JSON --> JSON1[metadata 객체 생성]
    JSON1 --> JSON2[api_status 추가]
    JSON2 --> JSON3[analysis 추가]
    JSON3 --> JSON4[collection_stats 추가]
    JSON4 --> JSON5[offline_reasons 추가<br/>해당 시만]
    JSON5 --> JSON6[json.dump<br/>summary_YYYYMMDD_HHMM.json]
    
    JSON6 --> CSV[CSV 보고서 생성]
    CSV --> CSV1[csv_data 리스트 구성<br/>API별 루프]
    CSV1 --> CSV2[DataFrame 변환]
    CSV2 --> CSV3[df.to_csv<br/>api_status_YYYYMMDD_HHMM.csv]
    
    CSV3 --> TXT[TXT 보고서 생성]
    TXT --> TXT1[헤더 문자열 생성<br/>f-string 포맷팅]
    TXT1 --> TXT2[offline_reasons 추가<br/>조건부]
    TXT2 --> TXT3[데이터 수집 현황 루프]
    TXT3 --> TXT4[분석 결과 포맷팅]
    TXT4 --> TXT5[운항 판정 포맷팅]
    TXT5 --> TXT6[Resilience 메모<br/>조건부]
    TXT6 --> TXT7[파일 저장<br/>summary.txt]
    
    TXT7 --> HTML[HTML 보고서 생성]
    HTML --> HTML1[DOCTYPE + CSS 스타일]
    HTML1 --> HTML2[헤더 섹션<br/>메타데이터 p 태그]
    HTML2 --> HTML3[테이블 생성<br/>api_status 루프]
    HTML3 --> HTML31[CSS 클래스 결정<br/>success/warning/error]
    HTML31 --> HTML4[분석 결과 ul/li]
    HTML4 --> HTML5[운항 판정 ul/li<br/>클래스 적용]
    HTML5 --> HTML6[Resilience 메모<br/>조건부]
    HTML6 --> HTML7[파일 저장<br/>summary.html]
    
    HTML7 --> RETURN[반환값 생성]
    RETURN --> RET1[json_path]
    RETURN --> RET2[csv_path]
    RETURN --> RET3[txt_path]
    RETURN --> RET4[html_path]
    RETURN --> RET5[summary_json]
    
    RET5 --> END([종료: 파일 경로 딕셔너리])
    
    style JSON6 fill:#e3f2fd
    style CSV3 fill:#e8f5e9
    style TXT7 fill:#fff3e0
    style HTML7 fill:#fce4ec
    style END fill:#c5cae9
            </div>
        </div>

        <!-- 코드 예시 -->
        <h2>💻 핵심 코드 예시</h2>
        
        <h3>1. JSON 보고서 생성</h3>
        <div class="code-block">
<pre>summary_json = {
    "metadata": {
        "generated_at": datetime.now().isoformat(),
        "location": data["location"],
        "forecast_hours": data["forecast_hours"],
        "system_version": "v2.3",
        "execution_mode": execution_mode,
        "resilience_mode": bool(resilience_notes),
    },
    "api_status": data["api_status"],
    "analysis": analysis,
    "collection_stats": {
        "total_timeseries": len(data["timeseries"]),
        "total_data_points": analysis.get("total_data_points", 0),
        "data_collection_rate": collection_rate,
    },
    "resilience_notes": resilience_notes,
}

json_path = output_path / f"summary_{timestamp}.json"
with open(json_path, "w", encoding="utf-8") as f:
    json.dump(summary_json, f, ensure_ascii=False, indent=2)</pre>
        </div>

        <h3>2. HTML 테이블 생성 (동적)</h3>
        <div class="code-block">
<pre>for api_name, status in data["api_status"].items():
    conf = status.get("confidence", 0)
    conf_txt = f"{conf:.2f}"
    
    # CSS 클래스 동적 결정
    status_class = (
        "success" if "✅" in status['status'] 
        else "warning" if "⚠️" in status['status'] 
        else "error"
    )
    
    html_content += f"""
        &lt;tr class='{status_class}'&gt;
            &lt;td&gt;{api_name}&lt;/td&gt;
            &lt;td&gt;{status['status']}&lt;/td&gt;
            &lt;td&gt;{conf_txt}&lt;/td&gt;
        &lt;/tr&gt;
    """</pre>
        </div>

        <h3>3. 통계 계산 (평균값)</h3>
        <div class="code-block">
<pre>avg_eri = sum(p.eri_value for p in all_eri_points) / len(all_eri_points)
avg_wind = sum(p.wind_speed_ms for p in all_eri_points) / len(all_eri_points)
avg_wave = sum(p.wave_height_m for p in all_eri_points) / len(all_eri_points)

# 실측값 (온라인 모드, 121개 포인트):
# avg_eri: 0.249
# avg_wind: 9.2 m/s
# avg_wave: 0.57 m</pre>
        </div>

        <!-- 성능 지표 -->
        <h2>⚡ 성능 지표 (v2.3 실측값)</h2>
        
        <table>
            <thead>
                <tr>
                    <th>항목</th>
                    <th>온라인 모드</th>
                    <th>오프라인 모드</th>
                    <th>비고</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>총 데이터 포인트</strong></td>
                    <td><span class="highlight">121개</span></td>
                    <td>24개</td>
                    <td>5배 차이</td>
                </tr>
                <tr>
                    <td><strong>데이터 수집 시간</strong></td>
                    <td>&lt;30초</td>
                    <td>&lt;3초</td>
                    <td>API 호출 vs 합성</td>
                </tr>
                <tr>
                    <td><strong>ERI 계산 시간</strong></td>
                    <td>0.05초</td>
                    <td>0.01초</td>
                    <td>121 vs 24 포인트</td>
                </tr>
                <tr>
                    <td><strong>보고서 생성 시간</strong></td>
                    <td>0.5초</td>
                    <td>0.1초</td>
                    <td>4가지 형식</td>
                </tr>
                <tr style="background: #e8f5e9;">
                    <td><strong>전체 처리 시간</strong></td>
                    <td><span class="highlight">&lt;35초</span></td>
                    <td>&lt;5초</td>
                    <td>수집부터 보고서까지</td>
                </tr>
                <tr>
                    <td><strong>메모리 사용량</strong></td>
                    <td>~100 KB</td>
                    <td>~30 KB</td>
                    <td>데이터 + 보고서</td>
                </tr>
                <tr>
                    <td><strong>디스크 사용량</strong></td>
                    <td>~15 KB</td>
                    <td>~8 KB</td>
                    <td>4가지 보고서</td>
                </tr>
            </tbody>
        </table>

        <!-- 결론 -->
        <div class="info-box" style="background: #e8f5e9; border-left-color: #4caf50;">
            <h3>🎯 핵심 요약</h3>
            <ul style="margin-left: 20px; line-height: 1.8;">
                <li><strong>4단계 파이프라인:</strong> 데이터 수집 → 분석 → 보고서 생성 → 알림</li>
                <li><strong>4가지 보고서 형식:</strong> JSON, CSV, TXT, HTML (각 용도별 최적화)</li>
                <li><strong>121개 데이터 포인트:</strong> 온라인 모드에서 4개 소스 통합</li>
                <li><strong>자동 폴백:</strong> API 실패 시 Resilience 메커니즘 작동</li>
                <li><strong>빠른 처리:</strong> 전체 파이프라인 &lt;35초 (온라인), &lt;5초 (오프라인)</li>
                <li><strong>높은 신뢰도:</strong> 평균 65% (Stormglass 85%, Open-Meteo 75%, NCM 70%)</li>
                <li><strong>100% 가용성:</strong> 온라인/오프라인 자동 전환</li>
            </ul>
        </div>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                diagramMarginX: 50,
                diagramMarginY: 10,
                actorMargin: 50,
                width: 150,
                height: 65,
                boxMargin: 10
            }
        });
    </script>
</body>
</html>

