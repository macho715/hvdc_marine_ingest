diff --git a/scripts/demo_operability_integration.py b/scripts/demo_operability_integration.py
index 3ee64af0a0cdfbeebfc5ccdc1f327b8c7a8c2937..d25f0d562c12f54ba2fb1b05be3da8e5e6923117 100644
--- a/scripts/demo_operability_integration.py
+++ b/scripts/demo_operability_integration.py
@@ -1,287 +1,264 @@
 #!/usr/bin/env python3
-"""
-KR: 통합된 운항 가능성 예측 데모
-EN: Integrated operability prediction demo
-
-이 스크립트는 HVDC 해양 데이터 수집 시스템과 operability_package를 통합하여
-실제 기상 데이터를 기반으로 운항 가능성 예측을 수행합니다.
-"""
+"""KR: 운항 가능성 예측 데모 / EN: Operability prediction demo."""
 
+import argparse
+import os
 import sys
 import json
 import pandas as pd
 from pathlib import Path
-from datetime import datetime, timedelta
-from typing import List, Dict, Any
+from datetime import datetime, timedelta, timezone
+from typing import Any, Dict, List, Tuple
 
 # 프로젝트 루트를 Python 경로에 추가
 project_root = Path(__file__).parent.parent
 sys.path.insert(0, str(project_root))
 
-from src.marine_ops.core.schema import MarineTimeseries, MarineDataPoint
-from src.marine_ops.operability.api import OperabilityPredictor, create_operability_report
+from src.marine_ops.core.schema import MarineTimeseries
+from src.marine_ops.operability.api import create_operability_report
 from src.marine_ops.connectors.stormglass import StormglassConnector
 from src.marine_ops.connectors.open_meteo import OpenMeteoConnector
-from src.marine_ops.connectors.worldtides import fetch_worldtides_heights, create_marine_timeseries_from_worldtides
-from src.marine_ops.eri.compute import ERICalculator
+from src.marine_ops.connectors.worldtides import create_marine_timeseries_from_worldtides
+from scripts.offline_support import decide_execution_mode, generate_offline_dataset
+
+def collect_weather_data(mode: str = "auto") -> Tuple[List[MarineTimeseries], str, List[str]]:
+    """KR: 기상 데이터 수집 / EN: Collect marine weather data."""
 
-def collect_weather_data() -> List[MarineTimeseries]:
-    """실제 기상 데이터 수집"""
     print("🌊 기상 데이터 수집 중...")
-    
-    weather_data = []
-    
-    # UAE 해역 좌표 (Dubai 근처)
+
     lat, lon = 25.2048, 55.2708
-    
-    try:
-        # Stormglass 데이터 수집
-        print("  📡 Stormglass API에서 데이터 수집...")
-        sg_connector = StormglassConnector()
-        sg_data = sg_connector.get_marine_weather(lat, lon, days=7)
-        if sg_data and sg_data.data_points:
-            weather_data.append(sg_data)
-            print(f"    ✅ {len(sg_data.data_points)}개 데이터 포인트 수집")
-        else:
-            print("    ⚠️ Stormglass 데이터 없음")
-    except Exception as e:
-        print(f"    ❌ Stormglass 오류: {e}")
-    
+    forecast_hours = 24 * 7
+    start_time = datetime.now(timezone.utc)
+    end_time = start_time + timedelta(hours=forecast_hours)
+    required_secrets = ["STORMGLASS_API_KEY", "WORLDTIDES_API_KEY"]
+    missing_secrets = [key for key in required_secrets if not os.getenv(key)]
+    resolved_mode, offline_reasons = decide_execution_mode(mode, missing_secrets, ncm_available=True)
+
+    if resolved_mode == "offline":
+        synthetic_series, _ = generate_offline_dataset("UAE_Waters", forecast_hours)
+        if offline_reasons:
+            print(f"⚠️ 오프라인 모드 전환: {', '.join(offline_reasons)}")
+        return synthetic_series, resolved_mode, offline_reasons
+
+    weather_data: List[MarineTimeseries] = []
+
+    stormglass_key = os.getenv("STORMGLASS_API_KEY", "")
+    if stormglass_key:
+        try:
+            print("  📡 Stormglass API에서 데이터 수집...")
+            sg_connector = StormglassConnector(api_key=stormglass_key)
+            sg_data = sg_connector.get_marine_weather(
+                lat,
+                lon,
+                start_time,
+                end_time,
+                location="UAE_Waters",
+            )
+            if sg_data and sg_data.data_points:
+                weather_data.append(sg_data)
+                print(f"    ✅ {len(sg_data.data_points)}개 데이터 포인트 수집")
+            else:
+                print("    ⚠️ Stormglass 데이터 없음")
+        except Exception as error:
+            print(f"    ❌ Stormglass 오류: {error}")
+    else:
+        print("  ⚠️ Stormglass API 키 없음으로 건너뜀")
+
     try:
-        # Open-Meteo 데이터 수집
         print("  📡 Open-Meteo API에서 데이터 수집...")
         om_connector = OpenMeteoConnector()
-        om_data = om_connector.get_marine_weather(lat, lon, days=7)
+        om_data = om_connector.get_marine_weather(
+            lat,
+            lon,
+            start_time,
+            end_time,
+            location="UAE_Waters",
+        )
         if om_data and om_data.data_points:
             weather_data.append(om_data)
             print(f"    ✅ {len(om_data.data_points)}개 데이터 포인트 수집")
         else:
             print("    ⚠️ Open-Meteo 데이터 없음")
-    except Exception as e:
-        print(f"    ❌ Open-Meteo 오류: {e}")
-    
-    try:
-        # WorldTides 데이터 수집
-        print("  📡 WorldTides API에서 데이터 수집...")
-        wt_key = "a7b5bd88-041e-4316-8f8e-02670eb44bc7"  # API 키
-        wt_raw = fetch_worldtides_heights(lat, lon, wt_key, hours=168)  # 7일
-        if wt_raw and 'heights' in wt_raw:
-            wt_data = create_marine_timeseries_from_worldtides(wt_raw, lat, lon)
+    except Exception as error:
+        print(f"    ❌ Open-Meteo 오류: {error}")
+
+    worldtides_key = os.getenv("WORLDTIDES_API_KEY", "")
+    if worldtides_key:
+        try:
+            print("  📡 WorldTides API에서 데이터 수집...")
+            wt_data = create_marine_timeseries_from_worldtides(
+                lat,
+                lon,
+                worldtides_key,
+                forecast_hours,
+                "UAE_Waters",
+            )
             if wt_data and wt_data.data_points:
                 weather_data.append(wt_data)
                 print(f"    ✅ {len(wt_data.data_points)}개 데이터 포인트 수집")
             else:
-                print("    ⚠️ WorldTides 데이터 변환 실패")
-        else:
-            print("    ⚠️ WorldTides 데이터 없음")
-    except Exception as e:
-        print(f"    ❌ WorldTides 오류: {e}")
-    
-    print(f"📊 총 {len(weather_data)}개 소스에서 데이터 수집 완료")
-    return weather_data
+                print("    ⚠️ WorldTides 데이터 없음")
+        except Exception as error:
+            print(f"    ❌ WorldTides 오류: {error}")
+    else:
+        print("  ⚠️ WorldTides API 키 없음으로 건너뜀")
 
-def create_synthetic_ensemble_data() -> List[MarineTimeseries]:
-    """합성 앙상블 데이터 생성 (실제 데이터가 부족할 경우)"""
-    print("🎲 합성 앙상블 데이터 생성...")
-    
-    import random
-    import numpy as np
-    from datetime import datetime, timedelta
-    
-    random.seed(42)
-    np.random.seed(42)
-    
-    # 7일간의 시간별 데이터 생성
-    data_points = []
-    base_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
-    
-    for day in range(7):
-        for hour in range(0, 24, 3):  # 3시간 간격
-            timestamp = base_time + timedelta(days=day, hours=hour)
-            
-            # 시간과 날짜에 따른 파라미터 변화
-            day_factor = 1 + (day * 0.05)  # 날이 지날수록 조건 악화
-            hour_factor = 1 + 0.1 * np.sin(hour / 4.0)  # 시간에 따른 변화
-            
-            # 파고 (Hs) 생성
-            hs_base = 0.8 + (day * 0.1) * hour_factor
-            hs = max(0.1, np.random.normal(hs_base, 0.2))
-            
-            # 풍속 생성
-            wind_base = 15.0 + (day * 0.5) * hour_factor
-            wind = max(0.5, np.random.normal(wind_base, 3.0))
-            
-            # 풍향 생성
-            wind_dir = np.random.uniform(0, 360)
-            
-            data_point = MarineDataPoint(
-                timestamp=timestamp.isoformat(),
-                wind_speed=wind,
-                wind_direction=wind_dir,
-                wave_height=hs,
-                wave_period=np.random.uniform(6, 12),
-                wave_direction=wind_dir + np.random.uniform(-30, 30),
-                sea_state="Moderate" if hs < 1.5 else "Rough",
-                visibility=np.random.uniform(8, 15),
-                temperature=np.random.uniform(22, 28),
-                confidence=0.7  # 합성 데이터 신뢰도
-            )
-            data_points.append(data_point)
-    
-    # MarineTimeseries 객체 생성
-    synthetic_timeseries = MarineTimeseries(
-        source="synthetic_ensemble",
-        location="UAE_Waters",
-        data_points=data_points,
-        ingested_at=datetime.now().isoformat()
-    )
-    
-    print(f"    ✅ {len(data_points)}개 합성 데이터 포인트 생성")
-    return [synthetic_timeseries]
+    if not weather_data:
+        print("⚠️ 외부 데이터가 없어 합성 데이터로 대체합니다.")
+        synthetic_series, _ = generate_offline_dataset("UAE_Waters", forecast_hours)
+        weather_data = synthetic_series
+        offline_reasons.append("외부 데이터 수집 실패")
+        resolved_mode = "offline"
+
+    print(f"📊 총 {len(weather_data)}개 소스에서 데이터 수집 완료")
+    return weather_data, resolved_mode, offline_reasons
 
 def run_operability_prediction(weather_data: List[MarineTimeseries]) -> Dict[str, Any]:
-    """운항 가능성 예측 실행"""
+    """KR: 운항 가능성 예측 실행 / EN: Run operability prediction."""
     print("🚢 운항 가능성 예측 실행 중...")
     
     # 항로 정보 정의
     routes = [
         {
             "name": "Abu Dhabi to AGI or DAS",
             "distance_nm": 65.0,
             "planned_speed_kt": 12.0,
             "hs_forecast": 1.2
         }
     ]
     
     # 운항 가능성 보고서 생성
     report = create_operability_report(
         weather_data=weather_data,
         routes=routes,
         forecast_days=7
     )
     
     print(f"    ✅ {len(report['operability_forecasts'])}개 운항 가능성 예측 완료")
     print(f"    ✅ {len(report['eta_predictions'])}개 ETA 예측 완료")
     
     return report
 
 def save_results(report: Dict[str, Any], output_dir: Path):
-    """결과 저장"""
+    """KR: 결과 저장 / EN: Persist results."""
     print("💾 결과 저장 중...")
     
     # JSON 보고서 저장
     json_file = output_dir / "operability_report.json"
     with open(json_file, 'w', encoding='utf-8') as f:
         json.dump(report, f, indent=2, ensure_ascii=False, default=str)
     print(f"  ✅ JSON 보고서: {json_file}")
     
     # CSV 형식으로 운항 가능성 예측 저장
     if report['operability_forecasts']:
         csv_data = []
         for forecast in report['operability_forecasts']:
             csv_data.append({
                 'day': forecast.day,
                 'daypart': forecast.daypart,
                 'P_go': forecast.probabilities.P_go,
                 'P_cond': forecast.probabilities.P_cond,
                 'P_nogo': forecast.probabilities.P_nogo,
                 'decision': forecast.decision,
                 'confidence': forecast.confidence,
                 'gate_hs_go': forecast.gate_used.hs_go,
                 'gate_wind_go': forecast.gate_used.wind_go
             })
         
         df_forecasts = pd.DataFrame(csv_data)
         csv_file = output_dir / "operability_forecasts.csv"
         df_forecasts.to_csv(csv_file, index=False)
         print(f"  ✅ 운항 가능성 예측 CSV: {csv_file}")
     
     # ETA 예측 CSV 저장
     if report['eta_predictions']:
         eta_data = []
         for eta in report['eta_predictions']:
             eta_data.append({
                 'route': eta.route,
                 'distance_nm': eta.distance_nm,
                 'planned_speed_kt': eta.planned_speed_kt,
                 'effective_speed_kt': eta.effective_speed_kt,
                 'eta_hours': eta.eta_hours,
                 'buffer_minutes': eta.buffer_minutes,
                 'hs_impact': eta.hs_impact
             })
         
         df_eta = pd.DataFrame(eta_data)
         eta_csv_file = output_dir / "eta_predictions.csv"
         df_eta.to_csv(eta_csv_file, index=False)
         print(f"  ✅ ETA 예측 CSV: {eta_csv_file}")
 
 def print_summary(report: Dict[str, Any]):
-    """결과 요약 출력"""
+    """KR: 결과 요약 출력 / EN: Print result summary."""
     print("\n" + "="*60)
     print("📊 운항 가능성 예측 결과 요약")
     print("="*60)
     
     summary = report['summary']
     print(f"📅 예측 기간: {report['forecast_days']}일")
     print(f"📈 총 예측 수: {summary['total_forecasts']}")
     print(f"✅ GO: {summary['go_count']}개")
     print(f"⚠️  CONDITIONAL: {summary['conditional_count']}개")
     print(f"❌ NO-GO: {summary['nogo_count']}개")
     print(f"🎯 평균 신뢰도: {summary['average_confidence']:.2f}")
     
     print("\n🚢 ETA 예측:")
     for eta in report['eta_predictions']:
         print(f"  • {eta.route}: {eta.eta_hours:.1f}시간 "
               f"(계획: {eta.planned_speed_kt}kt → 실제: {eta.effective_speed_kt:.1f}kt)")
     
     print("\n📋 일별 운항 가능성 (최소 P_go):")
     day_summary = {}
     for forecast in report['operability_forecasts']:
         day = forecast.day
         if day not in day_summary:
             day_summary[day] = []
         day_summary[day].append(forecast.probabilities.P_go)
     
     for day in sorted(day_summary.keys()):
         min_p_go = min(day_summary[day])
         status = "🟢" if min_p_go > 0.5 else "🟡" if min_p_go > 0.3 else "🔴"
         print(f"  {status} {day}: P(Go) = {min_p_go:.2f}")
 
-def main():
-    """메인 함수"""
+def parse_args() -> argparse.Namespace:
+    """KR: CLI 인자 파싱 / EN: Parse CLI arguments."""
+
+    parser = argparse.ArgumentParser(description="HVDC Marine operability demo")
+    parser.add_argument("--mode", choices=["auto", "online", "offline"], default="auto", help="실행 모드 (auto/online/offline)")
+    parser.add_argument("--output", default="out", help="결과 출력 디렉터리")
+    return parser.parse_args()
+
+
+def main() -> None:
+    """KR: 데모 실행 / EN: Run demo."""
+
+    args = parse_args()
+
     print("🚢 HVDC 해양 운항 가능성 예측 시스템")
-    print("="*50)
-    
-    # 출력 디렉토리 생성
-    output_dir = Path("out")
-    output_dir.mkdir(exist_ok=True)
-    
+    print("=" * 50)
+
+    output_dir = Path(args.output)
+    output_dir.mkdir(exist_ok=True, parents=True)
+
     try:
-        # 1. 기상 데이터 수집
-        weather_data = collect_weather_data()
-        
-        # 실제 데이터가 부족하면 합성 데이터 추가
-        if len(weather_data) == 0 or sum(len(ts.data_points) for ts in weather_data) < 50:
-            print("⚠️ 실제 데이터가 부족하여 합성 데이터를 추가합니다...")
-            synthetic_data = create_synthetic_ensemble_data()
-            weather_data.extend(synthetic_data)
-        
-        # 2. 운항 가능성 예측 실행
+        weather_data, resolved_mode, offline_reasons = collect_weather_data(args.mode)
+        print(f"⚙️ 실행 모드: {resolved_mode}")
+        if offline_reasons:
+            print("  ↳ 사유: " + ", ".join(offline_reasons))
+
         report = run_operability_prediction(weather_data)
-        
-        # 3. 결과 저장
         save_results(report, output_dir)
-        
-        # 4. 요약 출력
         print_summary(report)
-        
+
         print(f"\n✅ 운항 가능성 예측 완료! 결과는 {output_dir} 디렉토리에 저장되었습니다.")
-        
-    except Exception as e:
-        print(f"\n❌ 오류 발생: {e}")
+
+    except Exception as error:
+        print(f"\n❌ 오류 발생: {error}")
         import traceback
         traceback.print_exc()
         sys.exit(1)
 
+
 if __name__ == "__main__":
     main()
diff --git a/scripts/offline_support.py b/scripts/offline_support.py
new file mode 100644
index 0000000000000000000000000000000000000000..83f8a7804ff0191f37da949aa1f402cd31b8b7a0
--- /dev/null
+++ b/scripts/offline_support.py
@@ -0,0 +1,90 @@
+"""KR: GitHub Actions용 오프라인 지원 유틸 / EN: Offline support utilities for GitHub Actions."""
+from __future__ import annotations
+
+import os
+import math
+from datetime import datetime, timedelta, timezone
+from typing import Dict, List, Sequence, Tuple
+
+from src.marine_ops.core.schema import MarineDataPoint, MarineTimeseries
+
+
+def decide_execution_mode(requested_mode: str, missing_secrets: Sequence[str], ncm_available: bool) -> Tuple[str, List[str]]:
+    """KR: 실행 모드 결정 / EN: Decide execution mode."""
+
+    normalized = requested_mode.lower()
+    if normalized not in {"auto", "online", "offline"}:
+        raise ValueError(f"지원하지 않는 실행 모드입니다: {requested_mode}")
+
+    reasons: List[str] = []
+
+    if normalized == "offline":
+        reasons.append("사용자 지정 오프라인 모드")
+        return "offline", reasons
+
+    if normalized == "online":
+        return "online", reasons
+
+    if os.getenv("CI", "").lower() == "true":
+        reasons.append("CI 환경 자동 전환")
+
+    if missing_secrets:
+        reasons.append(f"필수 시크릿 누락: {', '.join(missing_secrets)}")
+
+    if not ncm_available:
+        reasons.append("NCM Selenium 모듈 미로드")
+
+    resolved_mode = "offline" if reasons else "online"
+    return resolved_mode, reasons
+
+
+def generate_offline_dataset(location: str, forecast_hours: int) -> Tuple[List[MarineTimeseries], Dict[str, Dict[str, float]]]:
+    """KR: 합성 해양 시계열 생성 / EN: Generate synthetic marine timeseries."""
+    now = datetime.now(timezone.utc).replace(minute=0, second=0, microsecond=0)
+    data_points: List[MarineDataPoint] = []
+
+    for hour in range(max(forecast_hours, 6)):
+        timestamp = now + timedelta(hours=hour)
+        phase = hour / 6.0
+        wind_speed = 8.5 + 1.8 * math.sin(phase)
+        wind_direction = (120 + 20 * math.cos(phase * 0.8)) % 360
+        wind_gust = wind_speed * 1.15
+        wave_height = 0.6 + 0.25 * math.sin(phase + 0.6)
+        wave_period = 7.5 + 0.4 * math.cos(phase)
+        visibility = 11.0 - 0.8 * math.sin(phase * 0.5)
+        temperature = 27.0 - 0.6 * math.cos(phase * 0.9)
+        sea_state = "Slight" if wave_height < 1.0 else "Moderate"
+
+        data_points.append(
+            MarineDataPoint(
+                timestamp=timestamp.isoformat(),
+                wind_speed=round(wind_speed, 2),
+                wind_direction=round(wind_direction, 2),
+                wave_height=round(wave_height, 2),
+                wind_gust=round(wind_gust, 2),
+                wave_period=round(wave_period, 2),
+                wave_direction=round((wind_direction + 5) % 360, 2),
+                sea_state=sea_state,
+                visibility=round(max(4.0, visibility), 2),
+                temperature=round(temperature, 2),
+                confidence=0.7,
+            )
+        )
+
+    synthetic_series = MarineTimeseries(
+        source="synthetic_offline",
+        location=location,
+        data_points=data_points,
+        ingested_at=datetime.now(timezone.utc).isoformat(),
+        confidence=0.7,
+    )
+
+    statuses: Dict[str, Dict[str, float]] = {
+        "STORMGLASS": {"status": "⚠️ 오프라인 모드", "confidence": 0.0},
+        "OPEN_METEO": {"status": "⚠️ 오프라인 모드", "confidence": 0.0},
+        "NCM_SELENIUM": {"status": "⚠️ 오프라인 모드", "confidence": 0.0},
+        "WORLDTIDES": {"status": "⚠️ 오프라인 모드", "confidence": 0.0},
+        "SYNTHETIC": {"status": "✅ 오프라인 합성 데이터", "confidence": synthetic_series.confidence or 0.7},
+    }
+
+    return [synthetic_series], statuses
diff --git a/scripts/weather_job.py b/scripts/weather_job.py
index 27b12faf118ed05277a848f71abc0a1268f8afde..b8e127372794d0c70f6e74973a883d67f04577fe 100644
--- a/scripts/weather_job.py
+++ b/scripts/weather_job.py
@@ -1,147 +1,189 @@
 #!/usr/bin/env python3
 """
 GitHub Actions용 해양 날씨 작업 스크립트
 매시간 실행되어 해양 날씨 데이터를 수집하고 요약 보고서를 생성합니다.
 """
 
 import os
 import sys
 import json
 import argparse
 from pathlib import Path
 from datetime import datetime, timedelta
+from typing import List
+
 import pandas as pd
 
 # 프로젝트 루트를 Python 경로에 추가
 project_root = Path(__file__).parent.parent
 sys.path.insert(0, str(project_root))
 
 from src.marine_ops.connectors.stormglass import StormglassConnector, LOCATIONS as SG_LOCATIONS
 from src.marine_ops.connectors.open_meteo import OpenMeteoConnector
 from src.marine_ops.connectors.worldtides import create_marine_timeseries_from_worldtides
-from ncm_web.ncm_selenium_ingestor import NCMSeleniumIngestor
 from src.marine_ops.eri.compute import ERICalculator
 from src.marine_ops.decision.fusion import ForecastFusion, OperationalDecisionMaker
-from src.marine_ops.core.schema import MarineTimeseries, MarineDataPoint, OperationalDecision, ERIPoint
+from src.marine_ops.core.schema import MarineTimeseries, ERIPoint
+from scripts.offline_support import decide_execution_mode, generate_offline_dataset
+
+try:
+    from ncm_web.ncm_selenium_ingestor import NCMSeleniumIngestor
 
+    NCM_IMPORT_ERROR: Exception | None = None
+except Exception as import_error:  # pragma: no cover - import guard
+    NCMSeleniumIngestor = None  # type: ignore[assignment]
+    NCM_IMPORT_ERROR = import_error
 def load_config(config_path: str) -> dict:
     """설정 파일 로드"""
     try:
         with open(config_path, 'r', encoding='utf-8') as f:
             if config_path.endswith('.yml') or config_path.endswith('.yaml'):
                 import yaml
                 return yaml.safe_load(f)
             else:
                 return json.load(f)
     except FileNotFoundError:
         print(f"설정 파일을 찾을 수 없습니다: {config_path}")
         return {}
 
-def collect_weather_data(location_name: str = "AGI", forecast_hours: int = 24) -> dict:
+def collect_weather_data(location_name: str = "AGI", forecast_hours: int = 24, mode: str = "auto") -> dict:
     """해양 날씨 데이터 수집"""
     print(f"🌊 {location_name} 해역 날씨 데이터 수집 시작...")
-    
+
     lat, lon = SG_LOCATIONS[location_name]['lat'], SG_LOCATIONS[location_name]['lon']
     now = datetime.now()
     end_date = now + timedelta(hours=forecast_hours)
-    
-    all_timeseries = []
-    api_status = {}
-    
+
+    required_secrets = ["STORMGLASS_API_KEY", "WORLDTIDES_API_KEY"]
+    missing_secrets = [key for key in required_secrets if not os.getenv(key)]
+    resolved_mode, offline_reasons = decide_execution_mode(mode, missing_secrets, NCMSeleniumIngestor is not None)
+
+    if resolved_mode == "offline":
+        synthetic_series, statuses = generate_offline_dataset(location_name, forecast_hours)
+        if offline_reasons:
+            print(f"⚠️ 오프라인 모드 전환: {', '.join(offline_reasons)}")
+        return {
+            'timeseries': synthetic_series,
+            'api_status': statuses,
+            'location': location_name,
+            'forecast_hours': forecast_hours,
+            'collected_at': now.isoformat(),
+            'mode': resolved_mode,
+            'offline_reasons': offline_reasons,
+        }
+
+    all_timeseries: List[MarineTimeseries] = []
+    api_status: dict[str, dict[str, float]] = {}
+
     # API 키 로드
     stormglass_key = os.getenv('STORMGLASS_API_KEY', '')
     worldtides_key = os.getenv('WORLDTIDES_API_KEY', '')
-    
+
     # 1. Stormglass 데이터 수집
     try:
         if stormglass_key:
             sg_connector = StormglassConnector(api_key=stormglass_key)
             sg_timeseries = sg_connector.get_marine_weather(lat, lon, now, end_date, location=location_name)
             all_timeseries.append(sg_timeseries)
             api_status['STORMGLASS'] = {
                 'status': '✅ 실제 데이터',
                 'confidence': getattr(sg_timeseries, 'confidence', 0.5)
             }
             print(f"✅ Stormglass: {len(sg_timeseries.data_points)}개 데이터 포인트")
         else:
             api_status['STORMGLASS'] = {'status': '❌ API 키 없음', 'confidence': 0.0}
             print("❌ Stormglass API 키 없음")
     except Exception as e:
         print(f"❌ Stormglass 수집 실패: {e}")
         api_status['STORMGLASS'] = {'status': '❌ 실패', 'confidence': 0.0}
-    
+
     # 2. Open-Meteo 데이터 수집
     try:
         om_connector = OpenMeteoConnector()
         om_timeseries = om_connector.get_marine_weather(lat, lon, now, end_date, location=location_name)
         all_timeseries.append(om_timeseries)
         api_status['OPEN_METEO'] = {
             'status': '✅ 실제 데이터',
             'confidence': getattr(om_timeseries, 'confidence', 0.5)
         }
         print(f"✅ Open-Meteo: {len(om_timeseries.data_points)}개 데이터 포인트")
     except Exception as e:
         print(f"❌ Open-Meteo 수집 실패: {e}")
         api_status['OPEN_METEO'] = {'status': '❌ 실패', 'confidence': 0.0}
-    
+
     # 3. NCM Selenium 데이터 수집
-    try:
-        ncm_ingestor = NCMSeleniumIngestor(headless=True)
-        ncm_timeseries = ncm_ingestor.create_marine_timeseries(location=location_name, forecast_hours=forecast_hours)
-        all_timeseries.append(ncm_timeseries)
-        api_status['NCM_SELENIUM'] = {
-            'status': '✅ 실제 데이터' if "fallback" not in ncm_timeseries.source else '⚠️ 폴백 데이터', 
-            'confidence': getattr(ncm_timeseries, 'confidence', 0.5)
-        }
-        print(f"✅ NCM Selenium: {len(ncm_timeseries.data_points)}개 데이터 포인트")
-    except Exception as e:
-        print(f"❌ NCM Selenium 수집 실패: {e}")
-        api_status['NCM_SELENIUM'] = {'status': '❌ 실패', 'confidence': 0.0}
-    
+    if NCMSeleniumIngestor is None:
+        api_status['NCM_SELENIUM'] = {'status': '❌ 모듈 누락', 'confidence': 0.0}
+        if NCM_IMPORT_ERROR is not None:
+            print(f"❌ NCM Selenium 로드 실패: {NCM_IMPORT_ERROR}")
+    else:
+        try:
+            ncm_ingestor = NCMSeleniumIngestor(headless=True)
+            ncm_timeseries = ncm_ingestor.create_marine_timeseries(location=location_name, forecast_hours=forecast_hours)
+            all_timeseries.append(ncm_timeseries)
+            api_status['NCM_SELENIUM'] = {
+                'status': '✅ 실제 데이터' if "fallback" not in ncm_timeseries.source else '⚠️ 폴백 데이터',
+                'confidence': getattr(ncm_timeseries, 'confidence', 0.5)
+            }
+            print(f"✅ NCM Selenium: {len(ncm_timeseries.data_points)}개 데이터 포인트")
+        except Exception as e:
+            print(f"❌ NCM Selenium 수집 실패: {e}")
+            api_status['NCM_SELENIUM'] = {'status': '❌ 실패', 'confidence': 0.0}
+
     # 4. WorldTides 데이터 수집 (선택사항)
     if worldtides_key:
         try:
             wt_timeseries = create_marine_timeseries_from_worldtides(lat, lon, worldtides_key, forecast_hours, location_name)
             all_timeseries.append(wt_timeseries)
             api_status['WORLDTIDES'] = {
                 'status': '✅ 실제 데이터',
                 'confidence': getattr(wt_timeseries, 'confidence', 0.5)
             }
             print(f"✅ WorldTides: {len(wt_timeseries.data_points)}개 데이터 포인트")
         except Exception as e:
             print(f"⚠️ WorldTides 수집 실패: {e}")
             api_status['WORLDTIDES'] = {'status': '⚠️ 크레딧 부족', 'confidence': 0.3}
     else:
         api_status['WORLDTIDES'] = {'status': '❌ API 키 없음', 'confidence': 0.0}
-    
+
+    if not all_timeseries:
+        print("⚠️ 외부 데이터가 없어 합성 데이터로 대체합니다.")
+        synthetic_series, synthetic_status = generate_offline_dataset(location_name, forecast_hours)
+        all_timeseries.extend(synthetic_series)
+        api_status.update(synthetic_status)
+        offline_reasons.append("외부 데이터 수집 실패")
+        resolved_mode = "offline"
+
     return {
         'timeseries': all_timeseries,
         'api_status': api_status,
         'location': location_name,
         'forecast_hours': forecast_hours,
-        'collected_at': now.isoformat()
+        'collected_at': now.isoformat(),
+        'mode': resolved_mode,
+        'offline_reasons': offline_reasons,
     }
 
 def analyze_weather_data(data: dict) -> dict:
     """수집된 날씨 데이터 분석"""
     print("📊 날씨 데이터 분석 중...")
     
     all_timeseries = data['timeseries']
     if not all_timeseries:
         return {'error': '수집된 데이터가 없습니다'}
     
     # ERI 계산
     eri_calculator = ERICalculator()
     all_eri_points = []
     
     for timeseries in all_timeseries:
         eri_points = eri_calculator.compute_eri_timeseries(timeseries)
         all_eri_points.extend(eri_points)
     
     # 예보 융합
     fusion_settings = {
         'ncm_weight': 0.60,
         'system_weight': 0.40,
         'alpha': 0.7,
         'beta': 0.3
     }
@@ -179,151 +221,164 @@ def analyze_weather_data(data: dict) -> dict:
         'decisions': {
             'total': len(decisions),
             'GO': go_count,
             'CONDITIONAL': conditional_count,
             'NO-GO': no_go_count
         },
         'averages': {
             'eri': avg_eri,
             'wind_speed_ms': avg_wind_speed,
             'wave_height_m': avg_wave_height
         },
         'eri_points': len(all_eri_points),
         'confidence_scores': [getattr(ts, 'confidence', 0.5) for ts in all_timeseries]
     }
 
 def generate_summary_report(data: dict, analysis: dict, output_dir: str) -> dict:
     """요약 보고서 생성"""
     print("📝 요약 보고서 생성 중...")
     
     output_path = Path(output_dir)
     output_path.mkdir(exist_ok=True)
     
     timestamp = datetime.now().strftime("%Y%m%d_%H%M")
     
     # JSON 요약
+    execution_mode = data.get('mode', 'online')
+    success_sources = sum(1 for status in data['api_status'].values() if '✅' in status['status'])
+    total_sources = max(len(data['api_status']), 1)
+    collection_rate = success_sources / total_sources * 100
     summary_json = {
         'metadata': {
             'generated_at': datetime.now().isoformat(),
             'location': data['location'],
             'forecast_hours': data['forecast_hours'],
-            'system_version': 'v2.1'
+            'system_version': 'v2.1',
+            'execution_mode': execution_mode,
         },
         'api_status': data['api_status'],
         'analysis': analysis,
         'collection_stats': {
             'total_timeseries': len(data['timeseries']),
             'total_data_points': analysis.get('total_data_points', 0),
-            'data_collection_rate': len([s for s in data['api_status'].values() if '✅' in s['status']]) / len(data['api_status']) * 100
+            'data_collection_rate': collection_rate,
         }
     }
+
+    if data.get('offline_reasons'):
+        summary_json['metadata']['offline_reasons'] = data['offline_reasons']
     
     json_path = output_path / f"summary_{timestamp}.json"
     with open(json_path, 'w', encoding='utf-8') as f:
         json.dump(summary_json, f, ensure_ascii=False, indent=2)
     
     # CSV 요약
     csv_data = []
     for api_name, status in data['api_status'].items():
         csv_data.append({
             'API': api_name,
             'Status': status['status'],
             'Confidence': status['confidence'],
             'Timestamp': datetime.now().isoformat()
         })
     
     csv_path = output_path / f"api_status_{timestamp}.csv"
     df = pd.DataFrame(csv_data)
     df.to_csv(csv_path, index=False, encoding='utf-8')
     
     # 텍스트 요약
     txt_content = f"""🌊 UAE 해역 해양 날씨 보고서
 ========================================
 생성 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
 위치: {data['location']} (Al Ghallan Island)
 예보 기간: {data['forecast_hours']}시간
-
-📊 데이터 수집 현황:
+실행 모드: {execution_mode.upper()}
 """
-    
+
+    if data.get('offline_reasons'):
+        txt_content += "오프라인 사유: " + "; ".join(data['offline_reasons']) + "\n"
+
+    txt_content += "\n📊 데이터 수집 현황:\n"
+
     for api_name, status in data['api_status'].items():
         conf = status.get('confidence', None)
         conf_txt = f"{conf:.2f}" if isinstance(conf, (int, float)) else "N/A"
         txt_content += f"  {api_name}: {status['status']} (신뢰도: {conf_txt})\n"
     
     txt_content += f"""
 📈 분석 결과:
   - 총 데이터 포인트: {analysis.get('total_data_points', 0):,}개
   - 융합 예보: {analysis.get('fused_forecasts', 0)}개
   - 평균 ERI: {analysis.get('averages', {}).get('eri', 0):.3f}
   - 평균 풍속: {analysis.get('averages', {}).get('wind_speed_ms', 0):.1f} m/s
   - 평균 파고: {analysis.get('averages', {}).get('wave_height_m', 0):.2f} m
 
 🚢 운항 판정:
   - GO: {analysis.get('decisions', {}).get('GO', 0)}회
   - CONDITIONAL: {analysis.get('decisions', {}).get('CONDITIONAL', 0)}회
   - NO-GO: {analysis.get('decisions', {}).get('NO-GO', 0)}회
 
 📋 상세 보고서: {json_path.name}
 """
     
     txt_path = output_path / "summary.txt"
     with open(txt_path, 'w', encoding='utf-8') as f:
         f.write(txt_content)
     
     print(f"✅ 요약 보고서 생성 완료:")
     print(f"  - JSON: {json_path}")
     print(f"  - CSV: {csv_path}")
     print(f"  - TXT: {txt_path}")
     
     return {
         'json_path': str(json_path),
         'csv_path': str(csv_path),
         'txt_path': str(txt_path),
         'summary_json': summary_json
     }
 
 def main():
     """메인 함수"""
     parser = argparse.ArgumentParser(description='GitHub Actions 해양 날씨 작업')
     parser.add_argument('--config', default='config/locations.yml', help='설정 파일 경로')
     parser.add_argument('--out', default='out', help='출력 디렉터리')
     parser.add_argument('--location', default='AGI', help='위치 코드')
     parser.add_argument('--hours', type=int, default=24, help='예보 시간')
+    parser.add_argument('--mode', choices=['auto', 'online', 'offline'], default='auto', help='실행 모드 (auto/online/offline)')
     
     args = parser.parse_args()
     
     print("🤖 GitHub Actions 해양 날씨 작업 시작")
     print("=" * 50)
     
     try:
         # 설정 로드
         config = load_config(args.config)
         print(f"✅ 설정 로드: {args.config}")
         
         # 날씨 데이터 수집
-        data = collect_weather_data(args.location, args.hours)
+        data = collect_weather_data(args.location, args.hours, args.mode)
         
         # 데이터 분석
         analysis = analyze_weather_data(data)
         
         # 요약 보고서 생성
         report = generate_summary_report(data, analysis, args.out)
         
         # 운항 가능성 예측 실행
         try:
             print("\n🚢 운항 가능성 예측 실행 중...")
             from src.marine_ops.operability.api import create_operability_report
             
             # 항로 정보 정의
             routes = [
                 {
                     "name": "Abu Dhabi to AGI or DAS",
                     "distance_nm": 65.0,
                     "planned_speed_kt": 12.0,
                     "hs_forecast": 1.2
                 }
             ]
             
             # 운항 가능성 보고서 생성
             # data는 딕셔너리이므로 MarineTimeseries 리스트 추출
             weather_timeseries = data.get('timeseries', [])
