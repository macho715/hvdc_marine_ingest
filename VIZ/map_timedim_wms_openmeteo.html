<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Marine Viz — TimeDimension: WW3(Hs) + Open‑Meteo Wind</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Esri-Leaflet (Oceans basemap) -->
  <script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>

  <!-- Leaflet.TimeDimension -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.0/dist/leaflet.timedimension.control.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.0/dist/leaflet.timedimension.min.js"></script>

  <style>
    :root{
      /* 3‑band cmocean-like palette for wind (low/mid/high) */
      --cmo-low:  #2c7fb8;
      --cmo-mid:  #fdae61;
      --cmo-high: #d7191c;
    }
    html,body,#map{height:100%;margin:0;background:#f3f4f6}
    .legend{
      position:absolute;bottom:12px;left:12px;background:#fff;padding:8px 10px;border-radius:8px;
      box-shadow:0 2px 8px rgba(0,0,0,.15);font:12px/1.45 system-ui,Segoe UI,Arial
    }
    .legend .sw{display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:6px;vertical-align:middle}
    code{background:#f6f8fa;padding:0 4px;border-radius:4px}
  </style>
</head>
<body>
<div id="map"></div>

<div class="legend">
  <div><b>Layers</b></div>
  <div>• Hs (WW3 ERDDAP WMS + TimeDimension)</div>
  <div>• Wind vectors (Open‑Meteo, u/v arrows)</div>
  <div style="margin-top:6px"><b>Palette (arrows, kt)</b></div>
  <div><span class="sw" style="background:var(--cmo-low)"></span>&lt; 10</div>
  <div><span class="sw" style="background:var(--cmo-mid)"></span>10–20</div>
  <div><span class="sw" style="background:var(--cmo-high)"></span>&ge; 20</div>
  <div style="margin-top:6px">Hs range: <code>0–2.5 m</code></div>
</div>

<script>
(async function(){
  // ---- Config ----
  const CENTER=[24.843833,53.655306]; // AGI
  const WMS_URL   = 'https://pae-paha.pacioos.hawaii.edu/erddap/wms/ww3_global/request';
  const WMS_LAYER = 'ww3_global:whgt';          // wind significant wave height (m) - 2017~현재 커버리지
  const HOURS_BACK = 24, HOURS_FWD = 48;        // slider window

  // ---- Map + TimeDimension ----
  const map = L.map('map', {
    center: CENTER, zoom: 7,
    timeDimension: true,
    timeDimensionControl: true,
    timeDimensionControlOptions: {
      position: "bottomleft",
      playerOptions: { transitionTime: 500, loop: true, startOver: true },
      autoPlay: false, speedSlider: true, timeSliderDragUpdate: true
    }
  });

  // Basemap with auto-fallback
  const osm = L.tileLayer(
    'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
    { maxZoom: 12, attribution: '© OpenStreetMap' }
  );

  let oceans;
  try {
    oceans = L.esri.basemapLayer('Oceans').addTo(map);
    oceans.on('tileerror', () => {         // 타일 실패 → 폴백
      if (map.hasLayer(oceans)) map.removeLayer(oceans);
      if (!map.hasLayer(osm)) osm.addTo(map);
    });
  } catch(e) {
    osm.addTo(map);
  }

  // ---- ERDDAP WMS (Hs) bound to TimeDimension ----
  const wmsBase = L.tileLayer.wms(WMS_URL, {
    layers: WMS_LAYER,
    format: 'image/png',
    transparent: true,
    opacity: 0.72,
    // 색 범위 고정(걸프 평시 가독 범위)
    COLORSCALERANGE: '0,2.5',
    NUMCOLORBANDS: 40,
    PALETTE: 'Rainbow' // 서버가 cmocean 지원 시 'cmocean/thermal' 등으로
  });

  // TimeDimension이 WMS 요청마다 time=...을 자동 주입
  L.timeDimension.layer.wms(wmsBase, {
    requestTimeFromCapabilities: true, // GetCapabilities에서 가능한 시간 가져오기
    updateTimeDimension: true,
    cache: 24
  }).addTo(map);

  // ---- Fetch Open‑Meteo wind hourly (UTC): past + forecast ----
  const lat=CENTER[0], lon=CENTER[1];
  const url = new URL("https://api.open-meteo.com/v1/forecast");
  url.search = new URLSearchParams({
    latitude: lat, longitude: lon, timezone: "UTC",
    past_days: 1, forecast_days: 2,
    hourly: "wind_speed_10m,wind_direction_10m"
  }).toString();
  const res = await fetch(url);
  const js  = await res.json();
  const timesISO = js.hourly.time;  // e.g., "2025-10-08T12:00"
  const spd  = js.hourly.wind_speed_10m;
  const dir  = js.hourly.wind_direction_10m;

  // Limit to sliding window [now-24h, now+48h]
  const now = new Date();
  const tmin = new Date(now.getTime() - HOURS_BACK*3600*1000);
  const tmax = new Date(now.getTime() + HOURS_FWD*3600*1000);

  const idx = [];
  for (let i=0;i<timesISO.length;i++){
    const t = new Date(timesISO[i] + "Z");
    if (t >= tmin && t <= tmax) idx.push(i);
  }
  const selTimes = idx.map(i => new Date(timesISO[i] + "Z")); // Date objects

  // Set TimeDimension available times
  map.timeDimension.setAvailableTimes(selTimes.map(x=>x.getTime()), 'replace');
  map.timeDimension.setCurrentTime(selTimes[0].getTime());

  // ---- Prepare sample points (small ring) to "spread" the same vector visually ----
  function ringPoints(center, radiusKm=20, stepDeg=30){
    const [lat0,lon0]=center, pts=[];
    for(let deg=0; deg<360; deg+=stepDeg){
      const rad = deg*Math.PI/180;
      const dlat = (radiusKm/111.0)*Math.cos(rad);
      const dlon = (radiusKm/(111.0*Math.cos(lat0*Math.PI/180)))*Math.sin(rad);
      pts.push([lat0+dlat, lon0+dlon]);
    }
    return pts;
  }
  const samples = ringPoints(CENTER, 18, 30);

  // ---- Wind arrows (pixel-based) that update on time changes ----
  const arrows = L.layerGroup().addTo(map);
  const PX_PER_KT = 0.9, MIN=6, MAX=28;
  function colorFor(spdKt){
    if (spdKt < 10) return getCSS('--cmo-low');
    if (spdKt < 20) return getCSS('--cmo-mid');
    return getCSS('--cmo-high');
  }
  function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name) || '#1F77B4'; }

  function uvAtIndex(i){
    const s = spd[i]; const d = dir[i]; // m/s & degrees (coming from)
    const rad = d*Math.PI/180;
    const u = -s*Math.sin(rad), v = -s*Math.cos(rad);
    return {u, v, s};
  }

  function renderForTime(ms){
    arrows.clearLayers();
    // Find closest time index
    const target = ms;
    let bestI=idx[0], bestDiff=Infinity;
    for (const ii of idx){
      const tt = new Date(timesISO[ii]+"Z").getTime();
      const diff = Math.abs(tt - target);
      if (diff < bestDiff){ bestDiff = diff; bestI = ii; }
    }
    const {u,v,s} = uvAtIndex(bestI);
    const spdKt = s*1.94384;
    const Lpx = Math.min(MAX, Math.max(MIN, PX_PER_KT*spdKt));
    const col = colorFor(spdKt);

    for (const [la,lo] of samples){
      const start = map.latLngToLayerPoint([la,lo]);
      const speed = Math.hypot(u,v); if (speed<0.1) continue;
      const ux=u/speed, uy=-v/speed;  // screen Y down
      const endPt = L.point(start.x + Lpx*ux, start.y + Lpx*uy);
      const endLL = map.layerPointToLatLng(endPt);
      L.polyline([[la,lo], endLL], {color: col, weight:1.7, opacity:0.9}).addTo(arrows);
      const back = L.point(start.x + 0.7*(endPt.x-start.x), start.y + 0.7*(endPt.y-start.y));
      const ortho = L.point(-(endPt.y-start.y), (endPt.x-start.x));
      const t1 = map.layerPointToLatLng(L.point(back.x + 0.12*ortho.x, back.y + 0.12*ortho.y));
      const t2 = map.layerPointToLatLng(L.point(back.x - 0.12*ortho.x, back.y - 0.12*ortho.y));
      L.polyline([t1, endLL, t2], {color: col, weight:1.1, opacity:0.9}).addTo(arrows);
    }
  }

  // Initial render & bind to TimeDimension events
  renderForTime(map.timeDimension.getCurrentTime());
  map.timeDimension.on('timechange', (e)=> renderForTime(map.timeDimension.getCurrentTime()));
  map.on('zoomend moveend', ()=> renderForTime(map.timeDimension.getCurrentTime()));
})();
</script>
</body>
</html>
