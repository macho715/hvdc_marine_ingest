<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Option A — WW3 WMS(TimeDimension) + Wind</title>
  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Esri-Leaflet (Oceans basemap) -->
  <script src="https://unpkg.com/esri-leaflet@3.0.11/dist/esri-leaflet.js"></script>
  <!-- Leaflet.TimeDimension -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.0/dist/leaflet.timedimension.control.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-timedimension@1.1.0/dist/leaflet.timedimension.min.js"></script>
  <style>
    :root{ --cmo-low:#2c7fb8; --cmo-mid:#fdae61; --cmo-high:#d7191c; }
    html,body,#map{height:100%;margin:0;background:#f3f4f6}
    .legend{position:absolute;bottom:12px;left:12px;background:#fff;padding:8px 10px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,.15);font:12px/1.45 system-ui,Segoe UI,Arial}
    .legend .sw{display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:6px;vertical-align:middle}
  </style>
</head>
<body>
<div id="map"></div>
<div class="legend">
  <div><b>Option A</b></div>
  <div>• WW3 Hs (WMS + TimeDimension)</div>
  <div>• Wind vectors (Open‑Meteo, time‑synced)</div>
  <div style="margin-top:6px"><b>Wind palette (kt)</b></div>
  <div><span class="sw" style="background:var(--cmo-low)"></span>&lt; 10</div>
  <div><span class="sw" style="background:var(--cmo-mid)"></span>10–20</div>
  <div><span class="sw" style="background:var(--cmo-high)"></span>&ge; 20</div>
  <div style="margin-top:6px">Hs scale: <code>0–2.5 m</code> (COLORSCALERANGE)</div>
</div>

<script>
(async function(){
  const CENTER=[24.843833,53.655306]; // AGI
  const map = L.map('map',{
    center: CENTER, zoom: 7,
    timeDimension: true,
    timeDimensionControl: true,
    timeDimensionControlOptions: {
      position:"bottomleft", playerOptions:{transitionTime:600, loop:true, startOver:true},
      autoPlay:false, speedSlider:true, timeSliderDragUpdate:true
    }
  });

  // Basemap with fallback
  const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:12, attribution:'© OpenStreetMap'});
  try{
    const oceans = L.esri.basemapLayer('Oceans').addTo(map);
    oceans.on('tileerror', ()=>{ if(map.hasLayer(oceans)){ map.removeLayer(oceans); } if(!map.hasLayer(osm)) osm.addTo(map);});
  }catch(e){ osm.addTo(map); }

  // WW3 (PacIOOS) WMS + TimeDimension
  const WMS_URL   = 'https://pae-paha.pacioos.hawaii.edu/erddap/wms/ww3_global/request';
  const WMS_LAYER = 'ww3_global:Thgt'; // 'whgt' / 'shgt' also available
  const wmsBase = L.tileLayer.wms(WMS_URL, {
    layers: WMS_LAYER, format:'image/png', transparent:true, opacity:0.72,
    COLORSCALERANGE:'0,2.5', NUMCOLORBANDS:40, PALETTE:'Rainbow'
  });
  L.timeDimension.layer.wms(wmsBase, {
    requestTimeFromCapabilities:true, updateTimeDimension:true, cache:24
  }).addTo(map);

  // Open‑Meteo hourly wind for time‑synced arrows
  const url = new URL('https://api.open-meteo.com/v1/forecast');
  url.search = new URLSearchParams({
    latitude:CENTER[0], longitude:CENTER[1], timezone:'UTC',
    past_days: 1, forecast_days: 2, hourly:'wind_speed_10m,wind_direction_10m'
  }).toString();
  const res = await fetch(url); const js = await res.json();
  const timesISO = js.hourly.time, spd=js.hourly.wind_speed_10m, dir=js.hourly.wind_direction_10m;

  // select a 72h window around now
  const now = new Date(); const tmin = new Date(now.getTime()-24*3600*1000); const tmax = new Date(now.getTime()+48*3600*1000);
  const selIdx=[], selTimes=[];
  for(let i=0;i<timesISO.length;i++){ const t=new Date(timesISO[i]+"Z"); if(t>=tmin && t<=tmax){ selIdx.push(i); selTimes.push(t.getTime()); }}
  map.timeDimension.setAvailableTimes(selTimes, 'replace'); if(selTimes.length) map.timeDimension.setCurrentTime(selTimes[0]);

  // Ring sample points
  function ringPoints(center, radiusKm=18, stepDeg=30){
    const [lat0,lon0]=center, pts=[];
    for(let deg=0;deg<360;deg+=stepDeg){
      const rad=deg*Math.PI/180;
      const dlat=(radiusKm/111.0)*Math.cos(rad);
      const dlon=(radiusKm/(111.0*Math.cos(lat0*Math.PI/180)))*Math.sin(rad);
      pts.push([lat0+dlat, lon0+dlon]);
    } return pts;
  }
  const samples = ringPoints(CENTER, 18, 30);

  // Pixel‑based arrows
  const arrows=L.layerGroup().addTo(map);
  const PX_PER_KT=0.9, MIN=6, MAX=28;
  function css(name){ return getComputedStyle(document.documentElement).getPropertyValue(name) || '#1F77B4'; }
  function colorFor(kt){ return kt<10?css('--cmo-low'):(kt<20?css('--cmo-mid'):css('--cmo-high')); }
  function uv(i){ const s=spd[i], d=dir[i]*Math.PI/180; const u=-s*Math.sin(d), v=-s*Math.cos(d); return {u,v,s}; }
  function nearestIndex(ms){
    let best=selIdx[0], bestd=Infinity;
    for(const i of selIdx){ const tt=new Date(timesISO[i]+"Z").getTime(); const d=Math.abs(tt-ms); if(d<bestd){bestd=d; best=i;} }
    return best;
  }
  function render(ms){
    arrows.clearLayers(); if(!selIdx.length) return;
    const i=nearestIndex(ms); const {u,v,s}=uv(i);
    const kt=s*1.94384; const Lpx=Math.min(MAX, Math.max(MIN, PX_PER_KT*kt)); const col=colorFor(kt);
    for(const [la,lo] of samples){
      const start=map.latLngToLayerPoint([la,lo]); const sp=Math.hypot(u,v); if(sp<0.1) continue;
      const ux=u/sp, uy=-v/sp; const end = L.point(start.x+Lpx*ux, start.y+Lpx*uy);
      const endLL=map.layerPointToLatLng(end);
      L.polyline([[la,lo], endLL], {color:col, weight:1.7, opacity:0.9}).addTo(arrows);
      const back=L.point(start.x+0.7*(end.x-start.x), start.y+0.7*(end.y-start.y));
      const ortho=L.point(-(end.y-start.y), (end.x-start.x));
      const t1=map.layerPointToLatLng(L.point(back.x+0.12*ortho.x, back.y+0.12*ortho.y));
      const t2=map.layerPointToLatLng(L.point(back.x-0.12*ortho.x, back.y-0.12*ortho.y));
      L.polyline([t1,endLL,t2], {color:col, weight:1.1, opacity:0.9}).addTo(arrows);
    }
  }
  render(map.timeDimension.getCurrentTime());
  map.timeDimension.on('timechange', ()=>render(map.timeDimension.getCurrentTime()));
  map.on('zoomend moveend', ()=>render(map.timeDimension.getCurrentTime()));
})();
</script>
</body>
</html>
